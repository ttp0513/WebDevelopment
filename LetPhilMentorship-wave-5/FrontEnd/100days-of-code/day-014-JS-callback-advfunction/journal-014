# ðŸ“˜ Day 14 Journal â€“ JavaScript - Higher-Order Functions and Callbacks

## âœ… What I Did Today
Today was another logic-heavy grind with higher-order functions. I wrestled with chaining `.filter(), .map()`, and `.reduce()` in my library manager project, trying to sort books, apply bonuses, and summarize data. It felt messy at times, but every bug taught me something deeper about how these functions flow.

Even when I got stuck, I felt excited. These tools are powerful, and Iâ€™m starting to see how they shape clean, expressive code. I know mastery takes time, but Iâ€™m committed. As long as I keep practicing, Iâ€™ll get there. One function at a time.

## Higher Order Functions
### Definition
- Higher Order Functions is a function that takes one or more functions as arguments, returns a function or both
- They allow for more flexible and reusable code
### When to use

- Common use of high order functions is to abstract away complex operations
- Abstract repetitive logic (e.g., filtering, transforming data)
- Write cleaner, declarative code instead of manual loops
- Pass behavior as data (e.g., callbacks for event handling or async operations)
- Compose functions to build more complex behavior from simple parts


### Common higher-order functions: in JS
Each of theses take a callback function and applies it to element in an array

#### `.map()`
- `.map()` create a new array by applying a given function to each element of the original array
- It returns the same number of elements as original

##### Syntax
```js
const numbers = [3, 4, 5, 6, 7].map((element, index, array) => {
  // code block;
});
```

##### Common Usage
1. Converting an array of strings to uppercase
2. Doubling each number in an array
3. Extracting a property from each object in an array

Note: Cant remove specific elements from an array as map() return the same number of elements of the original 
##### Example
```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);
console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```
#### `.filter()`
- `.filter()` is used to create a new array with elements that pass a specified test
- If no elements pass the test, the `filter()` returns an **empty array**
- `.filter()` does not affect the original array

##### Syntax
```js
const numbers = [3, 4, 5, 6, 7].filter((element, index, array) => {
  // code block;
});
```
##### Common Usage
1. Create an array of only even/odd numbers
2. Remove `null` or `undefined` values from an array
3. Filter objects based on their properties
4. Implement search functionality

##### Example:
```js
const developers = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 },
  { name: "David", age: 25 }
];

const youngPeople = developers.filter((person) => person.age < 30);
console.log(youngPeople);
// [{ name: "Alice", age: 25 }, { name: "David", age: 25 }]
```

#### `.reduce()` or reducer function
- `.reduce()` processes an array and condenses it into a single value.
    - Single value can be a string, a number, an object, or another array
- `.reduce()` applies a function to each element in the array in order, then passes the result of each calculation on to the next

##### Syntax
```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue, index, array) => {
    //logic to update accumulator
    return updatedAccumulator;
  }, initialValue
  
);

```
- **An accumulator:** the running total or result
- **A current value:** the array element being processed
- **index (optional)**: the index of the current item
- **array (optional**): the original array
- **initialValue**:  the starting value for the accumulator (default is the first element's value if initialValue is not set)

##### Common Usage
1. Summing Numbers
2. Flattening Arrays, or cleaning up nested data structures, especially from APIs or form inputs.
3. Counting Occurrences, frequency analysis, tag counters

##### Example
```js
const numbers = [1, 2, 3, 4];
const total = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(total); // 10
```

#### `.every()`
- This method tests whether all elements in an array pass a test implements by a provided function.
##### Expected Output
- `true` if all elements in the array pass the provided function
- `false` if any element fails the test, the function will immediately stop checking the remaining elements and return false

##### Example
```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```
#### `.some`
- This method checks if at least one element passes the test
##### Expected Output
- `true` as soon as it finds an element that passes the test
- `false` if no elements pass the test (or the array is empty)
##### Example

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

#### `.sort()`
- This method is used to arrange the elements of an array and returns a reference to the sorted array
- This does not return a copy of the original array because the elements are sorted in place


##### Syntax
```js
array.sort(compareFunction);

```
- `compareFunction` is an optional parameter that specifies a function that defines the sort order

##### Expected Output 
When array contains:
- **string**:  alphabetical order
- **number**: sort method converts the elements to strings and then compares their sequences of UTF-16 code units values.
- **null/undefined**: sort treats null/holes as `undefined` when coerced to a string
- **object** sort converts object into "[object Object]"
- **Order**: small to large
    -  ``` [{ '20': 5 }, "a", "b", undefined, empty] ```
    

##### Sorting numeric values
```js 
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a,b) => a-b); // (a,b = > a - b) represents a compareFunction
// if a - b returns positive, a should come after b and vice versa
console.log(numbers;) // [3, 5, 10, 200, 414]

```
### Method Chaining
Method chaining is a programming technique that allows you to call multiple methods on the same object in a single line of code

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```
Note: Very long chains can become difficult to debug, as it's not immediately clear which step in the chain might be causing an issue.

In the context of method chaining, a method typically return the object itself (`this`) to allow further chaining

```js
let obj = {
    value: 1,
    increment: function() {
        this.value++;
        return this;
    },
    double: function() {
        this.value *= 2;
        return this;
    },
    getValue: function() {
        return this.value;
    }
};

let result = obj.increment() // this = 2
    .double() // this = 4
    .increment() // this = 5
    .getValue(); // this = 5
console.log(result);
``` 
